# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T12:23:41+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header

from models import (
    AcceptGrantRequest,
    AcceptGrantResponse,
    AccessDeniedException,
    AuthorizationException,
    CheckInLicenseRequest,
    CheckInLicenseResponse,
    CheckoutBorrowLicenseRequest,
    CheckoutBorrowLicenseResponse,
    CheckoutLicenseRequest,
    CheckoutLicenseResponse,
    ConflictException,
    CreateGrantRequest,
    CreateGrantResponse,
    CreateGrantVersionRequest,
    CreateGrantVersionResponse,
    CreateLicenseConfigurationRequest,
    CreateLicenseConfigurationResponse,
    CreateLicenseConversionTaskForResourceRequest,
    CreateLicenseConversionTaskForResourceResponse,
    CreateLicenseManagerReportGeneratorRequest,
    CreateLicenseManagerReportGeneratorResponse,
    CreateLicenseRequest,
    CreateLicenseResponse,
    CreateLicenseVersionRequest,
    CreateLicenseVersionResponse,
    CreateTokenRequest,
    CreateTokenResponse,
    DeleteGrantRequest,
    DeleteGrantResponse,
    DeleteLicenseConfigurationRequest,
    DeleteLicenseConfigurationResponse,
    DeleteLicenseManagerReportGeneratorRequest,
    DeleteLicenseManagerReportGeneratorResponse,
    DeleteLicenseRequest,
    DeleteLicenseResponse,
    DeleteTokenRequest,
    DeleteTokenResponse,
    EntitlementNotAllowedException,
    ExtendLicenseConsumptionRequest,
    ExtendLicenseConsumptionResponse,
    FailedDependencyException,
    FilterLimitExceededException,
    GetAccessTokenRequest,
    GetAccessTokenResponse,
    GetGrantRequest,
    GetGrantResponse,
    GetLicenseConfigurationRequest,
    GetLicenseConfigurationResponse,
    GetLicenseConversionTaskRequest,
    GetLicenseConversionTaskResponse,
    GetLicenseManagerReportGeneratorRequest,
    GetLicenseManagerReportGeneratorResponse,
    GetLicenseRequest,
    GetLicenseResponse,
    GetLicenseUsageRequest,
    GetLicenseUsageResponse,
    GetServiceSettingsRequest,
    GetServiceSettingsResponse,
    InvalidParameterValueException,
    InvalidResourceStateException,
    LicenseUsageException,
    ListAssociationsForLicenseConfigurationRequest,
    ListAssociationsForLicenseConfigurationResponse,
    ListDistributedGrantsRequest,
    ListDistributedGrantsResponse,
    ListFailuresForLicenseConfigurationOperationsRequest,
    ListFailuresForLicenseConfigurationOperationsResponse,
    ListLicenseConfigurationsRequest,
    ListLicenseConfigurationsResponse,
    ListLicenseConversionTasksRequest,
    ListLicenseConversionTasksResponse,
    ListLicenseManagerReportGeneratorsRequest,
    ListLicenseManagerReportGeneratorsResponse,
    ListLicenseSpecificationsForResourceRequest,
    ListLicenseSpecificationsForResourceResponse,
    ListLicensesRequest,
    ListLicensesResponse,
    ListLicenseVersionsRequest,
    ListLicenseVersionsResponse,
    ListReceivedGrantsForOrganizationRequest,
    ListReceivedGrantsForOrganizationResponse,
    ListReceivedGrantsRequest,
    ListReceivedGrantsResponse,
    ListReceivedLicensesForOrganizationRequest,
    ListReceivedLicensesForOrganizationResponse,
    ListReceivedLicensesRequest,
    ListReceivedLicensesResponse,
    ListResourceInventoryRequest,
    ListResourceInventoryResponse,
    ListTagsForResourceRequest,
    ListTagsForResourceResponse,
    ListTokensRequest,
    ListTokensResponse,
    ListUsageForLicenseConfigurationRequest,
    ListUsageForLicenseConfigurationResponse,
    NoEntitlementsAllowedException,
    RateLimitExceededException,
    RedirectException,
    RejectGrantRequest,
    RejectGrantResponse,
    ResourceLimitExceededException,
    ResourceNotFoundException,
    ServerInternalException,
    TagResourceRequest,
    TagResourceResponse,
    UnsupportedDigitalSignatureMethodException,
    UntagResourceRequest,
    UntagResourceResponse,
    UpdateLicenseConfigurationRequest,
    UpdateLicenseConfigurationResponse,
    UpdateLicenseManagerReportGeneratorRequest,
    UpdateLicenseManagerReportGeneratorResponse,
    UpdateLicenseSpecificationsForResourceRequest,
    UpdateLicenseSpecificationsForResourceResponse,
    UpdateServiceSettingsRequest,
    UpdateServiceSettingsResponse,
    ValidationException,
    XAmzTarget,
    XAmzTarget1,
    XAmzTarget2,
    XAmzTarget3,
    XAmzTarget4,
    XAmzTarget5,
    XAmzTarget6,
    XAmzTarget7,
    XAmzTarget8,
    XAmzTarget9,
    XAmzTarget10,
    XAmzTarget11,
    XAmzTarget12,
    XAmzTarget13,
    XAmzTarget14,
    XAmzTarget15,
    XAmzTarget16,
    XAmzTarget17,
    XAmzTarget18,
    XAmzTarget19,
    XAmzTarget20,
    XAmzTarget21,
    XAmzTarget22,
    XAmzTarget23,
    XAmzTarget24,
    XAmzTarget25,
    XAmzTarget26,
    XAmzTarget27,
    XAmzTarget28,
    XAmzTarget29,
    XAmzTarget30,
    XAmzTarget31,
    XAmzTarget32,
    XAmzTarget33,
    XAmzTarget34,
    XAmzTarget35,
    XAmzTarget36,
    XAmzTarget37,
    XAmzTarget38,
    XAmzTarget39,
    XAmzTarget40,
    XAmzTarget41,
    XAmzTarget42,
    XAmzTarget43,
    XAmzTarget44,
    XAmzTarget45,
    XAmzTarget46,
    XAmzTarget47,
    XAmzTarget48,
    XAmzTarget49,
)

app = MCPProxy(
    contact={
        'email': 'mike.ralphson@gmail.com',
        'name': 'Mike Ralphson',
        'url': 'https://github.com/mermade/aws2openapi',
        'x-twitter': 'PermittedSoc',
    },
    description='License Manager makes it easier to manage licenses from software vendors across multiple Amazon Web Services accounts and on-premises servers.',
    license={'name': 'Apache 2.0 License', 'url': 'http://www.apache.org/licenses/'},
    termsOfService='https://aws.amazon.com/service-terms/',
    title='AWS License Manager',
    version='2018-08-01',
    servers=[
        {
            'description': 'The AWS License Manager multi-region endpoint',
            'url': 'http://license-manager.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AWS License Manager multi-region endpoint',
            'url': 'https://license-manager.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AWS License Manager endpoint for China (Beijing) and China (Ningxia)',
            'url': 'http://license-manager.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
        {
            'description': 'The AWS License Manager endpoint for China (Beijing) and China (Ningxia)',
            'url': 'https://license-manager.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
    ],
)


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.AcceptGrant',
    description=""" Accepts the specified grant. """,
    tags=['grant_operations', 'grant_management_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def accept_grant(
    x__amz__target: XAmzTarget = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: AcceptGrantRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.CheckInLicense',
    description=""" Checks in the specified license. Check in a license when it is no longer in use. """,
    tags=['license_management_operations', 'license_management', 'token_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def check_in_license(
    x__amz__target: XAmzTarget1 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: CheckInLicenseRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.CheckoutBorrowLicense',
    description=""" Checks out the specified license for offline use. """,
    tags=[
        'license_management_operations',
        'license_management',
        'license_configuration_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def checkout_borrow_license(
    x__amz__target: XAmzTarget2 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: CheckoutBorrowLicenseRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.CheckoutLicense',
    description=""" <p>Checks out the specified license.</p> <note> <p>If the account that created the license is the same that is performing the check out, you must specify the account as the beneficiary.</p> </note> """,
    tags=['license_management_operations', 'license_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def checkout_license(
    x__amz__target: XAmzTarget3 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: CheckoutLicenseRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.CreateGrant',
    description=""" Creates a grant for the specified license. A grant shares the use of license entitlements with a specific Amazon Web Services account, an organization, or an organizational unit (OU). For more information, see <a href="https://docs.aws.amazon.com/license-manager/latest/userguide/granted-licenses.html">Granted licenses in License Manager</a> in the <i>License Manager User Guide</i>. """,
    tags=['grant_operations', 'grant_management_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_grant(
    x__amz__target: XAmzTarget4 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: CreateGrantRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.CreateGrantVersion',
    description=""" Creates a new version of the specified grant. For more information, see <a href="https://docs.aws.amazon.com/license-manager/latest/userguide/granted-licenses.html">Granted licenses in License Manager</a> in the <i>License Manager User Guide</i>. """,
    tags=['grant_operations', 'grant_management_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_grant_version(
    x__amz__target: XAmzTarget5 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: CreateGrantVersionRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.CreateLicense',
    description=""" Creates a license. """,
    tags=['license_management_operations', 'license_management', 'token_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_license(
    x__amz__target: XAmzTarget6 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: CreateLicenseRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.CreateLicenseConfiguration',
    description=""" <p>Creates a license configuration.</p> <p>A license configuration is an abstraction of a customer license agreement that can be consumed and enforced by License Manager. Components include specifications for the license type (licensing by instance, socket, CPU, or vCPU), allowed tenancy (shared tenancy, Dedicated Instance, Dedicated Host, or all of these), license affinity to host (how long a license must be associated with a host), and the number of licenses purchased and used.</p> """,
    tags=[
        'license_configuration_operations',
        'license_management',
        'license_management_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_license_configuration(
    x__amz__target: XAmzTarget7 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: CreateLicenseConfigurationRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.CreateLicenseConversionTaskForResource',
    description=""" Creates a new license conversion task. """,
    tags=['license_management_operations', 'license_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_license_conversion_task_for_resource(
    x__amz__target: XAmzTarget8 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: CreateLicenseConversionTaskForResourceRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.CreateLicenseManagerReportGenerator',
    description=""" Creates a report generator. """,
    tags=[
        'license_management',
        'report_generation_management',
        'license_usage_reporting',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_license_manager_report_generator(
    x__amz__target: XAmzTarget9 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: CreateLicenseManagerReportGeneratorRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.CreateLicenseVersion',
    description=""" Creates a new version of the specified license. """,
    tags=['license_management_operations', 'license_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_license_version(
    x__amz__target: XAmzTarget10 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: CreateLicenseVersionRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.CreateToken',
    description=""" <p>Creates a long-lived token.</p> <p>A refresh token is a JWT token used to get an access token. With an access token, you can call AssumeRoleWithWebIdentity to get role credentials that you can use to call License Manager to manage the specified license.</p> """,
    tags=['token_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_token(
    x__amz__target: XAmzTarget11 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: CreateTokenRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.DeleteGrant',
    description=""" Deletes the specified grant. """,
    tags=['grant_operations', 'grant_management_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_grant(
    x__amz__target: XAmzTarget12 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DeleteGrantRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.DeleteLicense',
    description=""" Deletes the specified license. """,
    tags=['license_management_operations', 'license_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_license(
    x__amz__target: XAmzTarget13 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DeleteLicenseRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.DeleteLicenseConfiguration',
    description=""" <p>Deletes the specified license configuration.</p> <p>You cannot delete a license configuration that is in use.</p> """,
    tags=['license_configuration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_license_configuration(
    x__amz__target: XAmzTarget14 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DeleteLicenseConfigurationRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.DeleteLicenseManagerReportGenerator',
    description=""" <p>Deletes the specified report generator.</p> <p>This action deletes the report generator, which stops it from generating future reports. The action cannot be reversed. It has no effect on the previous reports from this generator.</p> """,
    tags=[
        'license_management_operations',
        'license_management',
        'report_generation_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_license_manager_report_generator(
    x__amz__target: XAmzTarget15 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DeleteLicenseManagerReportGeneratorRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.DeleteToken',
    description=""" Deletes the specified token. Must be called in the license home Region. """,
    tags=['token_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_token(
    x__amz__target: XAmzTarget16 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DeleteTokenRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ExtendLicenseConsumption',
    description=""" Extends the expiration date for license consumption. """,
    tags=[
        'license_management_operations',
        'license_management',
        'license_configuration_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def extend_license_consumption(
    x__amz__target: XAmzTarget17 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ExtendLicenseConsumptionRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.GetAccessToken',
    description=""" Gets a temporary access token to use with AssumeRoleWithWebIdentity. Access tokens are valid for one hour. """,
    tags=['token_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_access_token(
    x__amz__target: XAmzTarget18 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GetAccessTokenRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.GetGrant',
    description=""" Gets detailed information about the specified grant. """,
    tags=['grant_operations', 'grant_management_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_grant(
    x__amz__target: XAmzTarget19 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GetGrantRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.GetLicense',
    description=""" Gets detailed information about the specified license. """,
    tags=['license_management_operations', 'license_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_license(
    x__amz__target: XAmzTarget20 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GetLicenseRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.GetLicenseConfiguration',
    description=""" Gets detailed information about the specified license configuration. """,
    tags=[
        'license_configuration_operations',
        'license_management',
        'grant_operations',
        'service_configuration_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_license_configuration(
    x__amz__target: XAmzTarget21 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GetLicenseConfigurationRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.GetLicenseConversionTask',
    description=""" Gets information about the specified license type conversion task. """,
    tags=['license_management', 'license_management_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_license_conversion_task(
    x__amz__target: XAmzTarget22 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GetLicenseConversionTaskRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.GetLicenseManagerReportGenerator',
    description=""" Gets information about the specified report generator. """,
    tags=[
        'license_management_operations',
        'license_management',
        'license_usage_reporting',
        'report_generation_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_license_manager_report_generator(
    x__amz__target: XAmzTarget23 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GetLicenseManagerReportGeneratorRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.GetLicenseUsage',
    description=""" Gets detailed information about the usage of the specified license. """,
    tags=[
        'license_management_operations',
        'license_usage_reporting',
        'license_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_license_usage(
    x__amz__target: XAmzTarget24 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GetLicenseUsageRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.GetServiceSettings',
    description=""" Gets the License Manager settings for the current Region. """,
    tags=['service_settings_operations', 'service_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_service_settings(
    x__amz__target: XAmzTarget25 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GetServiceSettingsRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListAssociationsForLicenseConfiguration',
    description=""" <p>Lists the resource associations for the specified license configuration.</p> <p>Resource associations need not consume licenses from a license configuration. For example, an AMI or a stopped instance might not consume a license (depending on the license rules).</p> """,
    tags=['license_configuration_operations', 'association_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_associations_for_license_configuration(
    x__amz__target: XAmzTarget26 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListAssociationsForLicenseConfigurationRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListDistributedGrants',
    description=""" Lists the grants distributed for the specified license. """,
    tags=['grant_operations', 'grant_management_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_distributed_grants(
    x__amz__target: XAmzTarget27 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListDistributedGrantsRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListFailuresForLicenseConfigurationOperations',
    description=""" Lists the license configuration operations that failed. """,
    tags=[
        'license_management_operations',
        'failure_tracking',
        'license_configuration_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_failures_for_license_configuration_operations(
    x__amz__target: XAmzTarget28 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListFailuresForLicenseConfigurationOperationsRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListLicenseConfigurations',
    description=""" Lists the license configurations for your account. """,
    tags=['license_configuration_operations', 'license_management', 'grant_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_license_configurations(
    x__amz__target: XAmzTarget29 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListLicenseConfigurationsRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListLicenseConversionTasks',
    description=""" Lists the license type conversion tasks for your account. """,
    tags=['license_management_operations', 'license_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_license_conversion_tasks(
    x__amz__target: XAmzTarget30 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListLicenseConversionTasksRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListLicenseManagerReportGenerators',
    description=""" Lists the report generators for your account. """,
    tags=['license_management', 'report_generation_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_license_manager_report_generators(
    x__amz__target: XAmzTarget31 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListLicenseManagerReportGeneratorsRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListLicenseSpecificationsForResource',
    description=""" Describes the license configurations for the specified resource. """,
    tags=['license_management_operations', 'license_management', 'token_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_license_specifications_for_resource(
    x__amz__target: XAmzTarget32 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListLicenseSpecificationsForResourceRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListLicenseVersions',
    description=""" Lists all versions of the specified license. """,
    tags=['license_management_operations', 'license_management', 'token_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_license_versions(
    x__amz__target: XAmzTarget33 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListLicenseVersionsRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListLicenses',
    description=""" Lists the licenses for your account. """,
    tags=['license_management_operations', 'license_management', 'token_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_licenses(
    x__amz__target: XAmzTarget34 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListLicensesRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListReceivedGrants',
    description=""" Lists grants that are received. Received grants are grants created while specifying the recipient as this Amazon Web Services account, your organization, or an organizational unit (OU) to which this member account belongs. """,
    tags=['grant_management_operations', 'grant_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_received_grants(
    x__amz__target: XAmzTarget35 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListReceivedGrantsRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListReceivedGrantsForOrganization',
    description=""" Lists the grants received for all accounts in the organization. """,
    tags=['grant_management_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_received_grants_for_organization(
    x__amz__target: XAmzTarget36 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListReceivedGrantsForOrganizationRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListReceivedLicenses',
    description=""" Lists received licenses. """,
    tags=[
        'license_management_operations',
        'license_management',
        'grant_management_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_received_licenses(
    x__amz__target: XAmzTarget37 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListReceivedLicensesRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListReceivedLicensesForOrganization',
    description=""" Lists the licenses received for all accounts in the organization. """,
    tags=[
        'license_management_operations',
        'license_management',
        'grant_management_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_received_licenses_for_organization(
    x__amz__target: XAmzTarget38 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListReceivedLicensesForOrganizationRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListResourceInventory',
    description=""" Lists resources managed using Systems Manager inventory. """,
    tags=['resource_inventory_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_resource_inventory(
    x__amz__target: XAmzTarget39 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListResourceInventoryRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListTagsForResource',
    description=""" Lists the tags for the specified license configuration. """,
    tags=['token_operations', 'resource_inventory_operations', 'tagging_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_tags_for_resource(
    x__amz__target: XAmzTarget40 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListTagsForResourceRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListTokens',
    description=""" Lists your tokens. """,
    tags=['token_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_tokens(
    x__amz__target: XAmzTarget41 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListTokensRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.ListUsageForLicenseConfiguration',
    description=""" Lists all license usage records for a license configuration, displaying license consumption details by resource at a selected point in time. Use this action to audit the current license consumption for any license inventory and configuration. """,
    tags=[
        'license_management_operations',
        'license_management',
        'license_configuration_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_usage_for_license_configuration(
    x__amz__target: XAmzTarget42 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ListUsageForLicenseConfigurationRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.RejectGrant',
    description=""" Rejects the specified grant. """,
    tags=['grant_operations', 'grant_management_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def reject_grant(
    x__amz__target: XAmzTarget43 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RejectGrantRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.TagResource',
    description=""" Adds the specified tags to the specified license configuration. """,
    tags=['tagging_operations', 'resource_inventory_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def tag_resource(
    x__amz__target: XAmzTarget44 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: TagResourceRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.UntagResource',
    description=""" Removes the specified tags from the specified license configuration. """,
    tags=['token_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def untag_resource(
    x__amz__target: XAmzTarget45 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: UntagResourceRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.UpdateLicenseConfiguration',
    description=""" Modifies the attributes of an existing license configuration. """,
    tags=['license_configuration_operations', 'license_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_license_configuration(
    x__amz__target: XAmzTarget46 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: UpdateLicenseConfigurationRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.UpdateLicenseManagerReportGenerator',
    description=""" <p>Updates a report generator.</p> <p>After you make changes to a report generator, it starts generating new reports within 60 minutes of being updated.</p> """,
    tags=[
        'license_management_operations',
        'report_generation_management',
        'license_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_license_manager_report_generator(
    x__amz__target: XAmzTarget47 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: UpdateLicenseManagerReportGeneratorRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.UpdateLicenseSpecificationsForResource',
    description=""" <p>Adds or removes the specified license configurations for the specified Amazon Web Services resource.</p> <p>You can update the license specifications of AMIs, instances, and hosts. You cannot update the license specifications for launch templates and CloudFormation templates, as they send license configurations to the operation that creates the resource.</p> """,
    tags=[
        'license_management_operations',
        'license_management',
        'license_configuration_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_license_specifications_for_resource(
    x__amz__target: XAmzTarget48 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: UpdateLicenseSpecificationsForResourceRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/#X-Amz-Target=AWSLicenseManager.UpdateServiceSettings',
    description=""" Updates License Manager settings for the current Region. """,
    tags=['service_settings_operations', 'service_configuration_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_service_settings(
    x__amz__target: XAmzTarget49 = Header(..., alias='X-Amz-Target'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: UpdateServiceSettingsRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
